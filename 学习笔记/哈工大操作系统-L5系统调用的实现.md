# 哈工大操作系统-L5系统调用的实现

[TOC]

本节课讲接口是如何实现的。即操作系统是怎么样来提供这些重要的函数的。



## 1. 不能随意访问内核

### 1.1 为何

如果能随意访问，那所有程序都可以随意访问存在内存中其他程序的数据，不安全。因此不能随意jump。

### 1.2 内核用户态/内核用户段

硬件设计将内核程序和用户程序隔离

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804142837863.png" alt="image-20210804142837863" style="zoom:50%;" />

- **内存分为：内核段和用户段。**
- **指令执行的状态分为：内核态和用户态**
- 数据段中会记录该段是内核段还是用户段。(gdt表中的ds的dpl为0/3)
  - **保护**: 想要访问数据时，会根据指令找gdt去找数据，然后系统会核查dpl和cpl的关系，来保护内存段。
- 当前的指令也会记载目前是处于内核态还是用户态。(cs的cpl为0/3)
- 只有内核态可以访问任何数据。用户态访问不了内核段。

### 1.3 中断(硬件提供的主动请求进入内核的方法)

**<font color = red> 中断：用户主动调用内核代码的唯一方式</font>**. 

对于x86cpu即为INT指令，INT指令执行前,先将该INT代码的数据的DS的DPL改为3，以允许用户代码通过idt找到该INT中断以进入内核;然后又将进入内核的代码的CPL改为0，以允许对内核的访问。一般为INT0x80.

### 1.3.1 系统调用的核心

- 用户程序中包含一段包含int指令的代码(这段代码一般是库函数)
- 操作系统写中断处理，获取想调程序的编号
- 操作系统根据编号执行相应代码

### 1.3.2 以pintf为例子

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804144440606.png" alt="image-20210804144440606" style="zoom:50%;" />

- 用户写程序时使用库函数printf()
- 而printf()中封装了另一个库函数write() (write()包含一段用宏展开的内嵌汇编代码)
- printf()和write()，将用户输入的格式化输出参数，转变为系统调用write()可以接受的参数。进而调用接口write()

### 1.3.3 write()如何实现

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804145647744.png" alt="image-20210804145647744" style="zoom:50%;" />

- write()中包含一段由宏定义展开的内嵌汇编代码, 使用INT0X80中断进入内核，并传入中断号4。

### 1.3.4 INT0X80干了什么

调用相应的中断处理程序。

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804150521980.png" alt="image-20210804150521980" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804151244564.png" alt="image-20210804151244564" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210804151430293.png" alt="image-20210804151430293" style="zoom:50%;" />

- 可以认为sys_write是一个系统接口

## 2. 总结

- 为了保护数据，将内核数据和用户数据分开。指令分成内核态和数据态，内存分为内核段和数据段。

  - 只有内核态可以访问所有数据

- 因为隔离开，所以用户只能通过中断来主动进入内核。如INT0x80中断。

- 用户主动进入内核的流程为：

  - 写一段包含库函数的代码
  - 库函数中封装了使用宏展开的汇编代码，汇编代码中包含INT0X80中断
  - 执行库函数后，系统进入中断，然后去执行中断处理函数
    - INT0x80的执行过程中，为了让用户执行这个中断，会在中断的执行之前将0x80的idt表设置为用户段，因此用户能访问中断的程序，进而执行这个中断。
  - 中断处理函数会去查表，执行相应的系统接口。比如INT0X80的4号中断，就是表中的4号系统接口system_write

  
