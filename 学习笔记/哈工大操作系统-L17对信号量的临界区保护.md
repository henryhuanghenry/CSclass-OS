# 哈工大操作系统-L17对信号量的临界区保护

[TOC]

<font color=red>靠临界区保护信号量，靠信号量实现进程的同步。</font>

## 1.共同修改共享的信号量会有问题

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807124628306.png" alt="image-20210807124628306" style="zoom:50%;" />

- 这就是为什么信号量需要保护的原因。
- 内核中所有的共享数据都需要保护。

## 2.竞争条件(Race Condition)

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807124916856.png" alt="image-20210807124916856" style="zoom:50%;" />

- **竞争条件: 和调度有关的共享数据语义错误**
- 错误由多个进程并发操作共享数据引起
- 错误和调度顺序有关，难于发现和调试

## 3.引出临界区和原子操作

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807125123821.png" alt="image-20210807125123821" style="zoom:50%;" />

- 原子操作：原子操作内的代码必须完整的被执行，中途允许被中断打断或者切换出去

## 4.临界区(Critical Section)

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807125625549.png" alt="image-20210807125625549" style="zoom:50%;" />

- **临界区：一次只允许一个进程进入的该进程的那一段代码**
  - 即，如果一些进程都有访问共享数据的代码，那么为了保证这些共享数据的正确性，在一个进程执行访问共享数据的代码的时候，别的进程是不能执行访问共享数据的代码的
  - **把每个进程中访问共享数据的代码的段，称为临界区**
  - **读写信号量的代码一定是临界区…**
- 一个非常重要的工作: 找出进程中的临界区代码
- 我们的目的就是：**合理设计临界区的进入和退出机制，保证共享数据的正确性**

## 5.临界区代码的保护三原则

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807125812900.png" alt="image-20210807125812900" style="zoom:50%;" />

- **互斥进入**--基本原则
  - 互斥进入: 如果一个进程在临界区中执行，则其他进程不允许进入。
  - 这些进程间的约束关系称为互斥(mutual exclusion)
  - 互斥进入保证了共享数据的正确性
- **有空让进**：临界区空闲就可以进入
- **有限等待**：不能让一些进程无限等待，防止造成饥饿

## 6.进入临界区设计的尝试

### 6.1轮换法

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807130145215.png" alt="image-20210807130145215" style="zoom:50%;" />

- 满足互斥的要求
- 但不满足有空让进
  - P0进入退出临界区之后，必须等P1进入退出临界区一次，才能轮到P0
  - 如果P1一直不执行到临界区，临界区一直空闲，P0也没法进入

### 6.2普通标记法

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807130422716.png" alt="image-20210807130422716" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807130526508.png" alt="image-20210807130526508" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807130706853.png" alt="image-20210807130706853" style="zoom:50%;" />

- 满足互斥
- 不满足有空让进
  - 普通标记会造成死锁

### 6.3非对称标记法

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807131002237.png" alt="image-20210807131002237" style="zoom:50%;" />

## 7.两进程的Peterson算法

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807131338644.png" alt="image-20210807131338644" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807131517759.png" alt="image-20210807131517759" style="zoom:50%;" />

- **Peterson算法概述**
  - 进入前先标记自己想进入
  - 然后，把turn让渡给另一个人
  - 如果 别人没有标记想进入&&turn也不是轮到别人的话，自己就进入
- 为何满足有空让进：
  - 如果一个进程不在临界区有三种状况
    - 执行到turn之后但还未进入临界区，让给别人执行，此时turn是别人，别人可以进入临界区
    - 执行到turn之前flag为ture，但还未进入临界区，让给别人执行，此时别人也访问不了，等待。但是时间片过后，就又到我们自己了，我们自己是可以进入临界区的，不存在死锁的问题
    - 执行到flag为false之后，别人都可以进入临界区
- 为何满足有限等待：
  - 因为一个进程执行过后，会让渡turn给别人，如果别人要求执行，那么别人肯定能进入临界区执行
  - 如果别人不要求执行，我们也还能继续执行
  - 但这个turn的作用就是，我执行过了，别人如果突然要求执行，别人的优先级高。但如果无人要求执行，我还是可以继续执行
- 要一直询问几个标记的值，也是一种**忙等**的行为



## 8.多进程的面包店算法

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807133255859.png" alt="image-20210807133255859" style="zoom:50%;" />



- **面包店算法概述**

  - 想进临界区先取号。
    - 取号前告诉别人我在取号。作用是让别人等我取完号再跟我比较。
    - 然后取一个比最大的都大1的号。
    - 告诉别人我取完号了
  - 逐个逐个问别人号数多少
    - 先看别人是否在取号，是，就等他取完再比较，否，就直接比较
    - 如果我号数是所有人里面最小的，我进入临界区；否则我一直轮询跟别人比

- 是一种**忙等**的行为

  

## 9.上述软件方法复杂，需要硬件方法

### 9.1阻止中断

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807134305900.png" alt="image-20210807134305900" style="zoom:50%;" />

- 单CPU好使
- 多CPU不好使

### 9.2原子指令

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210807134722951.png" alt="image-20210807134722951" style="zoom:50%;" />

- 用锁对共享资源保护
- 用原子指令设置只能单人开锁和关锁，那么就实现了对锁的保护