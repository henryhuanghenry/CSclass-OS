# 哈工大操作系统-L23段页结合的实际内存管理

[TOC]



- 用户用分段机制书写程序；系统用分页机制管理内存。
- 如何结合为本课核心。



## 1.虚拟内存--联系段和页的中间桥梁

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808151102179.png" alt="image-20210808151102179" style="zoom:50%;" />

- 虚拟内存把内存空间中的地址**按段分配给用户**使得**用户端是分段机制**
- 虚拟内存会把内存空间中的地址**按分页机制映射到物理地址**，这样子**对于系统，还是按分页机制存储的**
- 因为虚拟内存空间中的地址并不代表实际的物理地址，因此称为虚拟内存
- 对用户端，用户感觉不到虚拟内存的存在，因此用户端会认为是分段机制的
- 对于物理内存而言，映射也使得实际的存取是按页的，也支持系统的分页机制

## 2.段、页同时存在时的重定位(地址翻译)

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808151535216.png" alt="image-20210808151535216" style="zoom:50%;" />

经历两重的地址翻译：

- 分段的地址翻译--从用户端到虚拟地址空间
- 分页的地址翻译--从虚拟地址空间到物理地址

## 3.段页内存的实际实现

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808152351994.png" alt="image-20210808152351994" style="zoom:50%;" />

- 先在虚拟内存中，割出用户程序所需的各个段。(如何割？分区适配算法)
- 虚拟内存的各个段会被分割成页，放置在不同的页框。
- 段表记录用户程序的段信息
- 页表记录虚拟内存段分页的信息

### 3.1分配虚拟内存，建立段表

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808152740816.png" alt="image-20210808152740816" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808152954934.png" alt="image-20210808152954934" style="zoom:50%;" />

- LDT1应是记录程序段在虚拟内存的基址，LDT2应该是记录程序段结束的地址，初始化为基地址。
- 每个进程的代码段、数据段都是一个段
- **每个进程占据64MB的虚拟地址空间，互不重叠**
  - 互不重叠意味着，页表可以共用一套？
  - 因为是以虚拟地址为页号进行页框的查找

### 3.2 分配内存，建页表

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808153620424.png" alt="image-20210808153620424" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808154255938.png" alt="image-20210808154255938" style="zoom:50%;" />

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808154834823.png" alt="image-20210808154834823" style="zoom:50%;" />

### 3.3结果

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808154923607.png" alt="image-20210808154923607" style="zoom:50%;" />

### 3.4最后，MMU自动执行从逻辑地址到物理地址的转换

<img src="E:\AAAAAAAuniPPT\4_1PPT\CSclass-OS(git)\学习笔记\${图片}\image-20210808155117597.png" alt="image-20210808155117597" style="zoom:50%;" />

- 在子进程写*p=8时，我们不会再在原来的7300处保存这个P了。因为父进程的数据对子进程是只读的。
- 子进程会创建一个新的区块，去保存我们的指针p=8。即，翻译指针p时，尽管逻辑地址，以及由逻辑地址到虚拟内存地址都是与父进程一致的，但在虚拟地址映射到物理地址时，因为父进程的指针p是不能修改的，因此我们会把子进程的指针P的虚拟地址映射到新的物理地址，然后保存指针P的值。